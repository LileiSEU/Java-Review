# 消息中间件

## RabbitMQ

默认使用的**消息确认机制**，消息队列会将队列中的消息平均分配给消费者，若消费者在消费过程中出现宕机等问题，就会影响业务流程。同时，若部分消费者处理快，部分消费者处理慢，就无法达到能者多劳的实现。基于此，代码做出如下改进：

### RabbitMQ 工作模式

**Simple简单模式**

![image-20210109163020126](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210109163020126.png)

在上图的模型中，有以下概念：

- P：生产者，也就是要发送消息的程序；
- C：消费者，消息的接收者，会一直等待消息到来；
- queue：消息队列，图中红色部分，类似一个邮箱，可以缓存消息：生产者向其中投递消息，消费者从中取出消息。
- 点对点，一次只允许一个消费者消费，适合于登录或注册；



**work工作模式**

`Work queues`，也被称为(`Task queues`)，**任务模型**。当消息处理比较耗时的时候，可能生产消息的速度会远远大于消息的消费速度。长此以往，消息就会堆积越来越多，无法及时处理。此时就可以用一个work模型，**让多个消费者绑定到一个队列，共同消费队列中的消息**。队列中的消息一旦消费，就会消失，因此任务时不会被重复执行的。

![image-20210110102527473](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210110102527473.png)

角色：

- P：生产者：任务的发布者；
- C1：消费者，领取任务并且完成任务，假设完成速度较慢；
- C2：消费者2：领取任务并完成任务，假设完成速度快。

- Unacked：未被确认的消息



**发布订阅模式**

在广播模式下，消息发布流程是这样的：

- 可以有多个消费者
- 每个消费者有自己的 queue (队列)   **每个消费者绑定一个临时队列**
- 每个队列都要绑定到Exchange (交换机)
- 生产者发送的消息，只能发送到交换机，交换机来决定要发给哪个队列，生产者无法决定
- 交换机把消息发送给绑定过的所有队列
- 队列的消费者都能拿到消息，实现一条消息被多个消费者消费
- 前两种模型使用RabbitMQ的默认交换机
- 广播模型更适合于注册业务，注册成功后发短信、邮件、设置积分等业务；结算的时候，可以与订单等模块交互。
- 交换机类型为fanout，才可以用作广播模型的交换机



**Routing路由模型**

Routing 之订阅模型-Direct(直连)

`在Fanout模式中，一条消息，会被所有订阅的队列都消费。但是，在某些场景下，我们希望不同的消息被不同的队列消费。这时就要用到Direct类型的Exchange(交换机)。`

在Direct模型下：

- 队列与交换机的绑定，不能是任意绑定了，而是需要指定一个`RoutingKey`(路由Key)

- 消息的发送方在向Exchange发送消息时，也必须指定消息的`RoutingKey`.

- Exchange不再把消息交给每一个绑定的队列，而是根据消息的`RoutingKey`进行判断，只有队列的`RoutingKey`与消息的`RoutingKey`完全一致，才会接收到消息。

Routing 之订阅模型-Topic

`Topic`类型的`Exchange`与`Direct`相比，都是可以根据`RoutingKey`把消息路由到不同的队列。只不过 Topic 类型的交换机Exchange可以让队列在绑定Routing key 的时候使用通配符。这种模型 Routing Key 一般都是由一个或者多个单词组成，多个单词之间以"."分割。



### MQ的使用场景说明

**异步处理**

`场景说明：用户注册后，需要发送邮件和注册短信，传统的做法有两种 1.串行的方式  2.并行的方式`

`消息队列：`引入消息队列后，把发送邮件、短信不是必须的业务逻辑异步处理，可以使用`Fanout`广播模型。

**应用解耦**

`场景：双十一是购物狂节，用户下单后，订单系统需要通知库存系统，传统的做法就是订单系统调用库存系统的接口。`

这种做法有一个缺点：

当库存系统出现故障时，订单就会失败。订单系统和库存系统高耦合，引入消息队列

![image-20210110163354407](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210110163354407.png)

- `订单系统：`用户下单后，订单系统完成持久化处理，将消息写入消息队列，返回用户订单下单成功。
- `库存系统：`订阅下单的消息，获取下单消息，进行库操作。就算库存系统出现故障，消息队列也能保证消息的可靠投递，不会导致消息消失。

**流量削峰**

场景：`秒杀活动，一般会因为流量过大，导致应用挂掉，为了解决这个问题，一般在应用前端加入消息队列。

`作用：`

- 可以控制活动人数，超过此一定阈值的订单直接丢弃
- 可以缓解短时间的高流量压垮应用(应用程序按自己的最大能力获取订单)

![image-20210110163838822](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210110163838822.png)

1.用户的请求，服务器收到之后，首先写入消息队列，加入消息队列长度超过最大值，则直接抛弃用户请求或跳转到错误页面；

2.秒杀业务根据消息队列中的请求信息，在做后续处理。









## Kafka