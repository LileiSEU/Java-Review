# 计算机科学知识粗解

## 正则表达式

- 正则表达式(Regular  Expression) 是一种文本模式，包括普通字符(例如，a到z之间的字母)和特殊字符(称为“元字符”)。
- 正则表达式使用单个字符串来描述、匹配一系列匹配某个句法规则的字符串。

```shell
参考链接：https://www.runoob.com/regexp/regexp-example.html
```

### 1.  正则表达式-语法

正则表达式(Regular Expression)描述了一种字符串匹配的模式(Pattern)，可以用来检查一个串是否含有某种子串、将匹配的子串替换或者从某个串中取出符合某个条件的子串等。

```shell
# 普通字符
	普通字符包括没有显示指定为元字符的所有可打印和不可打印字符。这包括所有大写和小写字母、所有数字、所有标点符号和一些其他符号。
	[ABC]：匹配[...]中的所有字符；
	[^ABC]：匹配除了[...]中字符的所有字符；
	[A-Z]：[A-Z]表示一个区间，匹配所有大写字母，[a-z]表示所有小写字母；
	[\s\S]：匹配所有。\s是匹配所有空白符，包括换行，\S非空白符，包括换行；
	\w：匹配字母、数字、下划线。等价于[A-Za-z0-9_]
```

```shell
# 非打印字符
	非打印字符也可以是正则表达式的组成部分。
	\cx：匹配由x指明的控制字符；
	\f：匹配一个换页符，等价于\x0c 和 \cL
	\n：匹配一个换行符，
	\r：匹配一个回车符，
	\s：匹配任何空白字符，包括空格、制表符、换页符等等，等价于[\f\n\r\t\v]
	\S：匹配任何非空白字符，等价于[^\f\n\r\t\v]
	\t：匹配一个制表符，
	\v：匹配一个垂直制表符，
```

```shell
# 特殊字符
	所谓特殊字符，就是一些有特殊含义的字符。许多元字符要求在视图匹配它们时特别对待，若要匹配这些特殊字符，必须首先使用字符“转义”，即将反斜杠字符\放在它们前面。
	$: 匹配输入字符串的结尾位置，如果设置了RegExp对象的Multiline属性，则$也匹配'\n'或'\r'。要匹配$字符本身，使用\$；
	()：标记一个子表达式的开始和结束位置，子表达式可以获取供以后使用。要匹配这些字符，使用\(和\)；
	*：匹配前面的子表达式零次或多次。要匹配*字符，使用\*；
	+：匹配前面的子表达式一次或多次。要匹配+字符，使用\+；
	.：匹配除换行符\n之外的任何单字符，要匹配.，使用\.；
	[：标记一个中括号表达式的开始。要匹配[，请使用\[；
	?：匹配前面的子表达式零次或一次，或指明一个非贪婪限定符，要匹配?字符，使用\?；
	\：将下一个字符标记为或特殊字符、或原义字符、或向后引用，或八进制转义符，例如， 'n' 匹配字符 'n'。'\n' 匹配换行符。序列 '\\' 匹配 "\"，而 '\(' 则匹配 "("。
	^：匹配输入字符串的开始位置，除非在方括号表达式中使用，当该符号在方括号表达式中使用时，表示不接受该方括号表达式中的字符集合。要匹配^字符本身，使用\^；
	{：标记限定符表达式的开始。要匹配{,使用\{;
	|：指明两项之间的一个选择。要匹配|，使用\|。
```

```shell
# 限定符
	限定符用来指定正则表达式的一个给定组件必须要出现多少次才能满足匹配；
	*：匹配前面的子表达式零次或多次，*等价于{0,}
	+：匹配前面的子表达式一次或多次,+等价于{1,}
	?：匹配前面的子表达式零次或一次，?等价于{0,1}
	{n}：n是一个非负整数，匹配确定的n次；
	{n,}：n是一个非负整数，至少匹配n次；
	{n,m}：m和n均为非负整数，其中 n <= m，最少匹配n次且最多匹配m次。注意在逗号和两个数之间不能有空格。
	* 和 + 限定符都是贪婪的，因为它们会尽可能多的匹配文字，只有在它们的后面加上一个 ? 就可以实现非贪婪或最小匹配；
```

```shell
# 定位符
	定位符用来描述字符串或单词的边界，^ 和 $ 分别指字符串的开始与结束，\b 描述单词的前或后边界，\B 表示非单词边界。
	^：匹配输入字符串开始的位置。
	$：匹配输入字符串结尾的位置；
	\b：匹配一个单词边界，即字与空格间的位置；
	\B：非单词边界匹配
```

### 2. 正则表达式-修饰符

- 标记也称为修饰符，正则表达式的标记用于指定额外的匹配策略；
- 标记不写在正则表达式里，标记位于表达式之外，格式如下：`/pattern/flags`

```shell
# 正则表达式修饰符
	i：ignore - 不区分大小写，将匹配设置为不区分大小写，搜索是不区分大小写：A和a没有区别；
	g：global - 全局匹配，查找所有的匹配项；
	m：multiline - 多行匹配，	使边界字符 ^ 和 $ 匹配每一行的开头和结尾，记住是多行，而不是整个字符串的开头和结尾；
	s：特殊字符圆点 . 中包含换行符 \n，默认情况下的圆点 . 是 匹配除换行符 \n 之外的任何字符，加上 s 修饰符之后, . 中包含换行符 \n。
```



### 3. 匹配规则

```shell
# 字符簇
[a-z] //匹配所有的小写字母 
[A-Z] //匹配所有的大写字母 
[a-zA-Z] //匹配所有的字母 
[0-9] //匹配所有的数字 
[0-9\.\-] //匹配所有的数字，句号和减号 
[ \f\r\t\n] //匹配所有的白字符
```



## CPU Cache与缓存行

```shell
# 参考博客：https://www.jianshu.com/p/e338b550850f
```

```shell
# CPU Cache
	CPU访问内存时，首先查询Cache是否已缓存该数据。如果有，则返回数据，无需访问内存；如果不存在，则需把数据从内存中载入Cache，最后返回给处理器。在处理器看来，Cache是一个透明不见，旨在提高处理器访问内存的速率。Cache之所以有效，是因为程序对内存的访问存在一种概率上的局部特征：
	Spatial Locality:对于刚被访问的数据，其相邻的数据在将来被访问的概率高；
	Temporal Locality:对于刚被访问的数据，其本身在将来被访问的概率高；
# 计算机存储的基本结构
	L1、L2、L3分别表示一级缓存、二级缓存、三级缓存。越靠近CPU的缓存，速度越快，容量也越小。L1缓存小但很快，并且紧靠着在使用它的CPU内核。分为指令缓存和数据缓存；L2大一些，也慢一些，并仍然只能被一个单独的CPU核使用；L3更大、更慢，并且被单个插槽上的所有CPU核共享；最后是主存，由全部插槽上的所有CPU核共享。当CPU执行运算的时候，它先去L1查找所需的数据、再去L2、然后是L3，如果最后这些缓存中都没有，所需的数据就要去主内存拿。走得越远，运算耗费的时间就越长。所以要尽量确保数据在L1缓存中。
```

![image-20210126121427438](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210126121427438.png)

```shell
# 缓存行
	每个缓存里面都是由缓存行组成的，缓存系统中是以缓存行（cache line）为单位存储的。当多线程修改互相独立的变量时，如果这些变量共享同一个缓存行，就会无意中影响彼此的性能，这就是伪共享。图中说明了伪共享的问题。在核心1上运行的线程想更新变量X，同时核心2上的线程想要更新变量Y。不幸的是，这两个变量在同一个缓存行中。每个线程都要去竞争缓存行的所有权来更新变量。如果核心1获得了所有权，缓存子系统将会使核心2中对应的缓存行失效。当核心2获得了所有权然后执行更新操作，核心1就要使自己对应的缓存行失效。这会来来回回的经过L3缓存，大大影响了性能。如果互相竞争的核心位于不同的插槽，就要额外横跨插槽连接，问题可能更加严重。
# 缓存行带来的锁竞争
	处理器为了提高处理速度，不直接和内存进行通讯，而是先将系统内存的数据读到内部缓存（L1,L2或其他）后再进行操作，但操作完之后不知道何时会写到内存；如果对声明了Volatile变量进行写操作，JVM就会向处理器发送一条Lock前缀的指令，将这个变量所在缓存行的数据写回到系统内存。但是就算写回到内存，如果其他处理器缓存的值还是旧的，再执行计算操作就会有问题，所以在多处理器下，为了保证各个处理器的缓存是一致的，就会实现缓存一致性协议，每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器要对这个数据进行修改操作的时候，会强制重新从系统内存里把数据读到处理器缓存里。

```

![image-20210126123245682](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210126123245682.png)

















