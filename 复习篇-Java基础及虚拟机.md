# Java基础及虚拟机部分

## Part1：Java基础



## Part2：深入理解Java虚拟机

- JDK1.8默认垃圾回收器 Parallel Scavenge(新生代)+ Serial Old(老年代)；
- Windows默认虚拟机是Server模式；

```shell
# 抛出 OutOfMemoryError 异常
	1. 虚拟机栈动态扩展时无法申请到足够的内存，就会抛出 OOM 异常；
	2. 在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出 OutOfMemoryError 异常；
	3. 当方法区无法满足内存分配需求时，将抛出 OutOfMemoryError 异常；
	4. 运行时常量池无法申请到内存时会抛出 OOM 异常；
	5. 直接内存可能会导致各个内存区域总和大于物理内存限制(包括物理的和操作系统级的限制)，从而导致动态扩展时出现 OOM 异常；
```



```shell
# 对象的访问定位
# Sun HotSpot 虚拟机，是因为直接指针方式进行对象访问，好处就是速度快；
	1. 使用句柄
		使用句柄访问，Java 堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。
	2. 直接指针
		reference 中存储的直接就是对象地址。
```

![](D:\JAVA\Typora笔记\微信图片_20210116103728.jpg)

![](D:\JAVA\Typora笔记\微信图片_20210116103742.jpg)



```shell
# 垃圾收集的对象，确定哪些对象可以被回收
	1. 引用计数算法
		对象维护一个引用计数器，计数器值为0就是不会被使用的；问题：难以解决对象间循环引用的问题；
	2. 可达性分析算法(Reachability Analysis)
		通过一系列称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连时，证明此对象是不可用的。
		Java语言中，可作为GC Roots的对象包括下面几种：
		(对于一个 Java 程序而言，对象都位于堆内存块中，存活的那些对象都被根节点引用着，即根节点 GC Roots 是一些引用类型，自然不在堆里，是下面的)
			1. 虚拟机栈(栈帧中的本地变量表)中引用的对象；
			2. 方法区中类静态属性引用的对象；
			3. 方法区中常量引用的对象；
			4. 本地方法栈中JNI(即native方法)引用的对象；
		引用：
			强引用(Strong Reference):程序代码之中普遍存在的，类似“Object obj = new Object()”这类的引用，只要强引用还在，垃圾收集器永远不会回收掉被引用的对象；
			软引用(Soft Reference):用来描述一些有用但并非必需的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，会把这些对象列进回收范围之中进行第二次回收。
			弱引用(Weak Reference):描述非必需对象，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。
			虚引用(Phantom Reference):一个对象是否有虚引用的存在，完全不会对其生存时间构成影响。虚引用的唯一作用就是对象被收集器回收时收到一个系统通知。

# 回收方法区
	方法区(或者HotSpot虚拟机中的永久代)垃圾回收：废弃常量和无用的类。
		类需要同时满足下面三个条件才能算是“无用的类”：
			1. 该类的所有实例都已经被回收，即Java堆中不存在该类的任何实例；
			2. 加载该类的ClassLoader已经被回收；
			3. 该类对应的java.lang.Class对象没有在任何地方被引用，没有通过反射访问该类的方法；
```



```shell
# 垃圾收集算法
	1. 标记-清除算法(Mark-Sweep) --> 适用于老年代
		不足：1)效率问题，标记和清除两个过程的效率都不高；2)空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。
	2. 复制(Copying)算法 --> 适用于新生代
		将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor。当回收时，将Eden和Survivor中还存活着的对象一次性地复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。HotSpot虚拟机默认Eden和Survivor的大小比例是8:1。
	3. 标记-整理算法(Mark-Compact) --> 适用于老年代
		标记之后，所有存活的对象向一端移动，再直接清理掉端边界以外的内存。
```



```shell
# HotSpot 发起内存回收
	GC 进行时必须停顿所有Java执行进程来保证“一致性”(Sun 将这件事情称为 Stop The World)。HotSpot通过一组OopMap的数据结构来拿到对象引用，即HotSpot在OopMap的协助下，可以快速且准确地完成GC Roots枚举。程序执行只有到安全点(SafePoint)的位置才可以停顿下来开始GC，当GC需要中断线程的时候，采用主动式中断，各个线程主动去轮询中断标志，中断标志位真时挂起线程。轮询标志的地方有安全点、创建对象需要分配内存的地方。当程序不执行(例如线程处于Sleep或者Blocked状态)，使用安全区域(Safe Region)来解决。
	一致性：整个分析GC Roots期间，执行系统全部停顿，对象引用关系不发生变化。
	OopMap：从外部记录下栈里Reference类型变量的类型信息，存成一个映射表。
```



```shell
# HotSpot虚拟机中的垃圾收集器
虚拟机server模式:启动慢，编译更完全，编译器是自适应编译器，效率高，针对服务端应用优化，在服务器环境中最大化程序执行速度而设计。
虚拟机client模式:快速启动，内存占用少，编译快，针对桌面应用程序优化，为在客户端环境中减少启动时间而优化；
当JVM用于启动GUI界面的交互应用时适合于使用client模式，当JVM用于运行服务器后台程序时建议用Server模式。
	1. Serial收集器  --> 新生代收集器(复制算法)
		1)使用一个CPU或者一条收集线程去完成垃圾收集工作；
		2)垃圾收集时必须暂停其他所有的工作线程，直到收集结束。
		Serial收集器是虚拟机运行在Client模式下的默认新生代收集器。
	2. ParNew收集器  --> 新生代收集器(多线程复制算法)
		Serial收集器的多线程版本，使用多条线程并行进行垃圾收集；
		可以与CMS收集器配合工作；
		ParNew收集器是虚拟机运行在Server模式下首选的新生代收集器。
	3. Parallel Scavenge收集器  --> 新生代收集器(多线程复制算法)
		Parallel Scavenge收集器的目标是达到一个可控制的吞吐量。
	4. Serial Old收集器  --> 老年代收集器(单线程标记-整理算法)
		Serial Old是Serial收集器的老年代版本，单线程收集器，标记-整理算法；
		Client模式下的虚拟机使用；
	5. Parallel Old收集器  --> 老年代收集器(多线程标记-整理算法)
		Parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程和标记-整理算法；
		“吞吐量优先”收集器组合：Parallel Scavenge 和 Parallel Old收集器；
	6. CMS(Concurrent Mark Sweep)收集器  --> 老年代收集器(标记-清除算法)
		CMS收集器是一种以获取最短回收停顿时间为目标的收集器。CMS收集器回收老年代基于标记-清除算法，收集过程如下：
		1)初始标记(需要Stop The World)：初始标记仅仅只是标记一下GC Roots能直接关联到的对象，速度很快；
		2)并发标记：进行GC Roots Tracing的过程；
		3)重新标记(需要Stop The World)：修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，停顿时间比初始标记阶段长一些；
		4)并发清理
		CMS收集器的缺点：对CPU资源敏感、无法处理浮动垃圾、标记-清理算法的空间碎片；
		“浮动垃圾”：程序运行的垃圾在标记过程结束后产生，CMS无法在当次收集中处理只能留到下一次GC，即浮动垃圾
	7. G1收集器(Garbage-First)  -->面向服务端应用(新生代+老年代)
	  G1收集器特点：
	    并行与并发、空间整合(整体上标记-清理算法，两个Region复制算法)、可预测的停顿、分代收集
	    分代收集：独立管理整个堆，采用不同的方式去处理新创建的对象和已经存活了一段时间、熬过多次GC的旧对象； 
	  G1收集器运行过程：G1收集器将整个Java堆划分为多个大小相等的独立区域(Region)，新生代和老年代不再是物理隔离的，都是一部分Region(不需要连续)的集合，G1跟踪各个Region里面的垃圾堆积的价值大小，在后台维护一个优先列表，每次根据允许的回收时间，优先回收价值最大的Region。
	  在G1收集器中，Region之间的对象引用以及其他收集器中的新生代与老年代之间的对象引用，虚拟机都是使用Remember Set来避免全堆扫描的。
	  G1收集器回收过程：
	  初始标记阶段：标记GC Roots能直接关联到的对象，并且修改TAMS(Next Top at Mark Start)的值，让下一阶段用户程序并发运行时，能在正确可用的Region中创建新对象，这一阶段需要停顿，但耗时很短。
	  并发标记阶段：从GC Roots开始对堆中对象进行可达性分析，找出存活的对象，这阶段好使较长，但可以与用户程序并发执行；
	  最终标记阶段：为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，这一阶段需要停顿线程，可以并行执行；
	  筛选回收阶段：对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间来制定回收计划，可以并行执行；
```



```shell
# 内存分配与回收策略
	Java技术体系中所提倡的自动内存管理最终可以归结为自动化地解决了两个问题：给对象分配内存以及回收分配给对象的内存。对象的内存分配就是在堆(Java Heap)上分配，对象主要分配在新生代的Eden区，如果开启了本地线程分配缓存，将按线程优先在TLAB上分配。
	内存分配策略(Serial/Serial Old收集器)：对象优先在Eden分配、大对象直接进入老年代(大量连续空间)、长期存活的对象进入老年代(超过新生代年龄阈值)、动态对象年龄判定(Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于等于该年龄的对象就可以直接进行老年代)、空间分配担保(之前每次回收晋升到老年代对象容量的平均大小作为担保)
```



```shell
# 垃圾收集器中的并发和并行
	并行(Parallel)：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态；
	并发(Concurrent)：指用户线程与垃圾收集线程同时执行(但不一定是并行的，可能会交替执行)，用户程序在继续运行，而垃圾收集程序运行于另一个CPU上。
# 吞吐量：CPU用于运行用户代码的时间与CPU总消耗时间的比值；
# Minor GC 和 Full GC
新生代GC(Minor GC)：指发生在新生代的垃圾收集动作；
老年代GC(Major GC/Full GC)：指发生在老年代的GC，Full GC的速度一般会比Minor GC慢10倍以上；

触发MinorGC(Young GC)
    虚拟机在进行minorGC之前会判断老年代最大的可用连续空间是否大于新生代的所有对象总空间
    1、如果大于的话，直接执行minorGC
    2、如果小于，判断是否开启HandlerPromotionFailure，没有开启直接FullGC
    3、如果开启了HanlerPromotionFailure, JVM会判断老年代的最大连续内存空间是否大于历次晋升的大小，如果小于直接执行FullGC
    4、如果大于的话，执行minorGC
触发FullGC
	1)老年代空间不足:如果创建一个大对象，Eden区域当中放不下这个大对象，会直接保存在老年代当中，如果老年代空间也不足，就会触发Full GC。为了避免这种情况，最好就是不要创建太大的对象。
	2)持久代空间不足:如果有持久代空间的话，系统当中需要加载的类，调用的方法很多，同时持久代当中没有足够的空间，就出触发一次Full GC。
	3)YGC出现promotion failure:promotion failure发生在Young GC, 如果Survivor区当中存活对象的年龄达到了设定值，会就将Survivor区当中的对象拷贝到老年代，如果老年代的空间不足，就会发生promotion failure， 接下去就会发生Full GC。
	4)统计YGC发生时晋升到老年代的平均总大小大于老年代的空闲空间:在发生YGC是会判断，是否安全，这里的安全指的是，当前老年代空间可以容纳YGC晋升的对象的平均大小，如果不安全，就不会执行YGC,转而执行Full GC。
	5)显示调用System.gc
```



```shell
# Class 类文件的结构
	Class 文件是一组以8位字节为基础的二进制流，各个数据项目严格按照顺序紧凑地排列在Class文件中，中间没有添加任何分隔符，这使得整个Class文件中存储的内容几乎全部是程序运行的必要数据，没有空隙存在。当遇到需要占用8位字节以上空间的数据项时，则会按照高位在前的方式分割成若干个8位字节进行存储。
	Class文件格式中存在两种数据类型：无符号数和表；无符号数属于基本的数据类型，无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串。表示由多个无符号数或者其他表作为数据项构成的复合数据类型。
#  Class 类文件结构：
	1. 头4个字节：魔数(Magic Number),值为：0xCAFEBABE，标识能否被虚拟机接受;
	2. 第5、6个字节：次版本号
	3. 第7、8个字节：主版本号
	4. 常量池：
		常量池可以理解为class文件之中的资源仓库，常量池入口是一个u2类型的数据，代表常量池容量计数值(constant_pool_count),容量计数是从1开始，例如常量池容量为22，则常量池索引为1~21.Class文件中第0项常量空出来是为了满足后面某些指向常量池的索引值的数据在特定情况下需要表达“不引用任何一个常量池项目”的含义。
		常量池中主要存放两大类常量：字面量(Literal)和符号引用(Symbolic Reference)。符号引用包括：类和接口的全限定名(Fully Qualified Name)、字段的名称和描述符(Descriptor)和方法的名称和描述符。
		特殊记忆：字符串最大长度：64KB(65535)，CONSTANT_Utf8_info型常量(UTF-8缩略编码)的结构：u1 tag --->  u2 length  ---> u1 bytes(数量：bytes)；由于Class文件中方法、字段等都需要引用CONSTANT_Utf8_info型常量来描述名称，所以CONSTANT_Utf8_info型常量的最大长度也就是Java方法中方法、字段名的最大长度。而这里的最大长度就是length的最大值，即u2类型能表达的最大值65535.所以Java程序中如果定义了超过64KB英文字符的变量或方法名，将会无法编译。
	5. 访问标志(类或者接口层次的访问信息)
	6. 类索引、父类索引和接口索引集合
	7. 字段表集合
		字段表(field_ininfo)用于描述接口或者类中声明的变量。字段(field)包括类级变量以及实例级变量(是否被static修饰)，但不包括在方法内部声明的局部变量。字段表集合中不会列出从超类或者父接口中继承而来的字段。
	8. 方法表集合
		若父类方法在子类中没有被重写(Override)，方法集合中就不会出现来自父类的方法信息。
	9. 属性表集合
		在Class文件、字段表、方法表都可以携带自己的属性表集合，以用于描述某些场景专有的信息。
		Code属性：如果把Java程序中的信息分为代码(Code,方法体里面的Java代码)和元数据(Metadata，包括类、字段、方法定义及其他信息)，那么在整个class文件中，Code属性用于描述代码，所有的其他数据项目都用于描述元数据。
		任何实例方法里面 ，都可以通过this关键字来访问到此方法所属的对象(方法参数至少有一个this)。这个访问机制对Java程序的编写很重要，实现的时候通过javac编译器编译的时候，把对this关键字的访问转变为对一个普通方法参数的访问，然后虚拟机调用实例方法的时自动传入此参数即可。在实例的局部变量表中第0位索引的slot用于传递方法所属对象实例的引用，在方法中可以通过关键字this访问到这个隐含的参数。
```



```shell
# 字节码指令简介
	大多数对于boolean、byte、short和char类型数据的操作，实际上都是使用相应的int类型作为运算类型。
	Java虚拟机直接支持一下数据类型的宽化类型转换：
		1. int类型到long、float或者double类型；
		2. long类型到float、double类型；
		3. float类型到double类型；
```



```shell
# 虚拟机类加载机制
	# 概述
		虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。
		在Java语言中，类型的加载、连接和初始化过程都是在程序运行期间完成的。Java里天生可以动态扩展的语言特性就是依赖运行期动态加载和动态连接这个特点实现的。
	# 类加载的时机
		主动引用：虚拟机规范规定有且只有5种情况必须对类进行“初始化”
			1. 遇到new、getstatic、putstatic、或invokestatic这4条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。生成这4条指令的最常见的Java代码场景是：使用new关键字实例化对象的时候，读取或设置一个类的静态字段(被final修饰，已在编译期把结果放入常量池的静态的字段除外)的时候，以及调用一个类的静态方法的时候。
			2. 使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。
			3. 当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。
			4. 当虚拟机启动时，用户需要指定一个要执行的主类(包含main()方法的那个类)，虚拟机会先初始化这个主类。
			5. 当使用动态语言支持时，若java.lang.invoke.MethodHandle实例最后的解析结果的方法句柄，拽且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化。
		被动引用：除了上述5种主动引用类的方法外，所有引用类的方法都不会触发初始化；
			1. 通过子类引用父类的静态字段，不会导致子类初始化。对于静态字段，只有直接定义这个字段的类才会被初始化。
			2. 通过数组定义来引用类，不会触发此类的初始化。例：SuperClass[] sca = new SuperClass[10], 不会导致SuperClass类的初始化。
			3. 常量(final修饰)在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。
		接口主动引用与类主动引用的区别：
			接口与类真正有所区别的是初始化场景中的第3种：一个接口在初始化时，并不要求其父接口全部都完成了初始化，只有在真正使用到父接口的时候(如引用接口中定义的常量)才会初始化。
```



 ```shell
# 类加载的过程
	1.加载，在加载阶段，虚拟机需要完成一下3件事情：
		1)通过一个类的全限定名来获取定义此类的二进制字节流；
		2)将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构；
		3)在内存中生成一个代表这个类的java.lang.Class对象(HotSpot虚拟机存放在方法区中)，作为方法区这个类的各种数据的访问入口。
		数组类本身不通过类加载器创建，它是由Java虚拟机直接创建的，一个数组类创建过程：如果数组的组件类型是引用类型，就递归加载过程去加载组件类型，数组C将在加载该组件类型的类加载器的类名称空间上被表示；若数组的组件类型不是引用类型，Java虚拟机将会把数组C标记为与引导类加载器关联；数组类的可见性与它的组件类型的可见性一致，若组件类型不是引用类型则数组类的可见性默认为public。
	2. 验证(连接阶段第一步)
		验证阶段大致上会完成下面4个阶段的检验动作：文件格式验证、元数据验证、字节码验证、符号引用验证。
	3. 准备(连接阶段第二步)
		准备阶段是正式为类变量分配内存并设置类变量(static修饰的变量)初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。
	4. 解析(连接阶段第三步)
		解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。
		符号引用(Symbolic Reference):符号引用一一组符号来描述所引用的目标。
		直接引用(Direct Reference):直接引用可以使直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。除invokedynamic指令外，虚拟机实现可以对第一次解析的结果进行缓存从而避免解析动作重复进行。
		1)类或接口的解析：当前代码在类D，未解析过的符号N指向类或接口C的直接引用过程：若C不是一个数组类型，则将代表N的全限定名传给类D的类加载器去加载类C；若C是一个数组类型，且数组的元素类型是对象，则先加载数组元素类型，再由虚拟机生成代表数组维度和元素的数组对象。
		2)字段解析：解析字段所属的类或接口 --> 字段属于C --> 自下向上递归搜索接口和父接口是否有该字段 --> 自下向上递归搜索父类是否有该字段；
		3)类方法解析：方法 --> 解析属于C --> 递归解析父类 --> 递归解析父接口
		4)接口方法解析：方法 --> 解析属于接口C ---> 递归解析父接口
	5. 初始化
		初始化阶段是执行类构造器<clinit>()方法的过程，<clinit>()方法特点：
		1)<clinit>()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块(static{}块)中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在静态语句块之后的变量，在前面的静态语句块中可以赋值，但是不能访问。
		2)<clinit>()方法与类的构造函数(或者说实例构造器<init>()方法)不同，不需要显式地调用父类构造器，虚拟机会保证在子类的<clinit>()方法执行前，父类的<clinit>()方法已经执行完毕。因此在虚拟机中第一个被执行的<clinit>()方法的类肯定是java.lang.Object。
		3)由于父类的<clinit>()方法先执行，也就意味着父类中定义的静态语句块要优先于子类的变量赋值操作；
		4)<clinit>()方法对于类或接口来说不是必需的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成<clinit>()方法；
		5)接(在interface里面的变量都是public static final的)口的<clinit>()方法不需要先执行父接口的<clinit>()方法，只有当父接口中定义的变量使用时，父接口才初始化；
		6)虚拟机会保证一个类的<clinit>()方法在多线程环境中被正确地加速、同步，多个线程同时初始化一个类，只有一个线程执行类的<clinit>()方法，其余线程阻塞等待。
 ```



```shell
# 类加载器
	虚拟机设计团队把类加载阶段中的“通过一个类的全限定名来获取描述此类的二进制字节流”这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需要的类，实现这个动作的代码模块称为“类加载器”；
	对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性。
	#  双亲委派模型
		从虚拟机角度来讲，只存在两种不同的类加载器：一种是启动类加载器(Bootstrap ClassLoader)，这个类加载器使用C++语言实现，是虚拟机自身的一部分；另一种就是所有其他的类加载器，这些类加载器都由Java语言实现，独立于虚拟机外部，并且全部都继承自抽象类java.lang.ClassLoader；
		从开发人员的角度来看，绝大部分Java程序都会用到以下3种系统提供的类加载器：
			1.启动类加载器(BootStrap ClassLoader)：存放在<JAVA_HOME>\lib目录中的，并且是虚拟机识别的类库加载到虚拟机内存中；
			2. 扩展类加载器(Extension ClassLoader):存放在<JAVA_HOME>\lib\ext目录指定的路径中的所有类库；
			3. 应用程序类加载器(Application ClassLoader): 系统类加载器，负责加载用户类路径(ClassPath)上所指定的类库，一般情况下程序中默认使用应用程序类加载器；
	类加载器的双亲委派模型：
```

![image-20210120175957286](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210120175957286.png)

```shell
# 类加载器的双亲委派模型(Parents Delegation Model)
	双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。这里类加载器的父子关系使用组合(Composition)关系来复用父加载器的代码(组合自己理解就是子类加载器LoadClass方法中组合对父类加载器的使用)。
	双亲委派模型的工作过程是：如果一个类加载器收到了类加载请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此。因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求时，子加载器才会尝试自己去加载。
	双亲委派模型的代码逻辑：实现双亲委派模型的方法在ClassLoader类中的loadClass()方法中：先检查是否已经被加载过，若没有加载则调用父加载器的loadClass()方法，若父加载器为空则默认使用启动类加载器作为父加载器；若父类加载失败，抛出ClassNotFoundException异常后，再调用自己的findClass()方法进行加载。
    # 破坏双亲委派模型
    	线程上下文类加载器(Thread Context ClassLoader);
    	OSGi 环境下，类加载器不再是双亲委派模型中的树状结构，而是进一步发展为更加复杂的网状结构；
```

```java
protected Class<?> loadClass(String name, boolean resolve)
        throws ClassNotFoundException
    {
        synchronized (getClassLoadingLock(name)) {
            // First, check if the class has already been loaded
            Class<?> c = findLoadedClass(name);
            if (c == null) {
                long t0 = System.nanoTime();
                try {
                    if (parent != null) {
                        // 父类加载器
                        c = parent.loadClass(name, false);
                    } else {
                        // 启动类加载器
                        c = findBootstrapClassOrNull(name);
                    }
                } catch (ClassNotFoundException e) {
                    // ClassNotFoundException thrown if class not found
                    // from the non-null parent class loader
                }

                if (c == null) {

                    long t1 = System.nanoTime();
                    // 本身的findClass()方法进行类加载
                    c = findClass(name);

                    // this is the defining class loader; record the stats
                    sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);
                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);
                    sun.misc.PerfCounter.getFindClasses().increment();
                }
            }
            if (resolve) {
                resolveClass(c);// 连接操作，native方法
            }
            return c;
        }
    }
```



  ```shell
# 虚拟机字节码执行引擎
	在不同的虚拟机实现里面，执行引擎在执行Java代码的时候可能会有解释执行(通过解释器执行)和编译执行(通过即时编译器产生本地代码)两种选择。
	# 运行时栈帧结构
		栈帧(Stack Frame)是用于支持虚拟机进行方法调用和方法执行的数据结构，它是虚拟机运行时数据区中的虚拟机栈(Virtual Machine Stack)的栈元素。每一个栈帧都包括了局部变量表、操作数栈、动态连接、方法返回地址和一些额外的附加信息。每一个方法从调用开始至执行完成的过程，都对应看一个栈帧在虚拟机栈里面从入栈到出栈的过程。
		1. 局部变量表(Local Variable Table)
			局部变量表示一组变量存储空间，用于存放方法参数和方法内部定义的局部变量。局部变量表的容量以变量槽(Variable Slot)为最小单位。在方法执行时，虚拟机使用局部变量表完成参数值到参数变量表的传递过程。若执行的是实例方法，则局部变量表中的第0位索引的Slot默认是用于传递方法所属对象实例的引用，在方法中可以通过关键字"this"来访问到这个隐含的参数，其余参数则按照参数表顺序排序，占用从1开始的局部变量Slot。
			类变量有两次赋初始值过程：第一次是在类加载过程中的准备阶段，赋予系统初始值；第二次是在初始化阶段，赋予程序员定义的初值。因此，即使在初始化阶段程序员没有为类变量赋值也没有关系，类变量仍然具有一个确定的初始值。但局部变量就不一样，如果一个局部变量定义了但是没有赋初始值是不能使用的。
		2. 操作数栈(Operand Stack)
			操作数栈也称为操作栈，它是一个先入后出栈(First In Last Out)。当一个方法刚开始执行的时候，方法的操作数栈是空的，在方法的执行过程中，会有各种字节码指令往操作数栈中写入和提取内容，即入栈和出栈操作。在大多数虚拟机的实现中，下面栈帧的操作数栈与上面栈帧的局部变量表重叠在一起，这样在进行方法调用时就可以共用一部分数据，无需进行额外的参数复制传递。Java虚拟机的解释执行引擎称为“基于栈的执行引擎”，该栈就是操作数栈。
		3. 动态连接(Dynamic Linking)
			静态解析、动态连接
		4. 方法返回地址
  ```



```shell
# 方法调用
  方法调用阶段的唯一任务就是确定被调用方法的版本。所有方法调用中的目标方法在Class文件里面都是一个常量池中的符号引用。
  # 解析(类加载的解析阶段)(Resolution)
  	在类加载的解析阶段，会将其中的一部分符号引用转化为直接引用，这种解析能成立的前提是：调用目标在程序代码写好、编译器进行编译时就必须确定下来，这类方法的调用称为解析。在Java语言中符合“编译期可知，运行期不变”这个要求的方法，主要包括静态方法和私有方法两大类。
  	在类加载的解析阶段符合条件的有：静态方法、私有方法、实例构造器、父类方法和final修饰的方法，这些方法又称为非虚方法，在类加载的时候就会把符号引用解析为直接引用(内存布局中的入口地址)。
  	解析调用定义时一个静态的过程，在编译期间就完全确定，在类装载的解析阶段就会把涉及的符号引用全部转变为可确定的直接引用，不会延迟到运行期再去完成。
  # 分派
  	1. 静态分派(编译阶段)
  	Human man = new Man(); "Human"称为变量的静态类型，"Man"称为变量的实际类型。
  		所有依赖静态类型来定位方法执行版本的分派动作称为静态分派。静态分派的典型应用是方法重载(Overload)。静态分派发生在编译阶段；编译器在重载时通过参数的静态类型而不是实际类型作为判定依据的，并且静态类型是编译期可知。
  	2. 动态分派(运行阶段，invokevirtual指令)
  		动态分派和多态性的另外一个体现：重写(Override)关联。把在运行期根据实际类型确定方法执行版本的分派过程称为动态分派。
  		将要执行方法的所属对象，称为接收者(Receiver)；invokevirtual指令的多态查找过程，invokevirtual指令用于调用对象的实例方法，该指令的运行时解析过程：
  		1) 找到操作数栈顶的第一个元素所指向的对象的实际类型，记作C；
  		2) 如在类C中找到与常量中的描述符和简单名称都相符的方法，则进行访问权限校验，通过则直接返回这个方法的直接引用，查找过程结束；否则，返回 java.lang.IllegalAccessError异常；
  		3) 否则，按照继承关系从下往上依次对C的各个父类进行第2步的搜索和验证过程；
  		4) 始终没有找到合适的方法，则抛出 java.lang.AbstractMethodError 异常；
  		由于 invokevirtual 指令执行的第一步就是在运行期确定接收者的实际类型，所以调用过程中的 invokevirtual 指令把常量池中的类方法符号引用解析到了不同的直接引用上，这个过程就是Java语言方法重写的本质(Override)。
  	3. 单分派与多分派
  		方法的接收者与方法的参数统称为方法的宗量。
  		Java代码编译阶段：静态分派属于多分派类型；
  		Java运行阶段：动态分派属于单分派类型；
  # 虚拟机动态分派的实现
  	最常用的“稳定优化”手段就是为类在`方法区`中建立一个`虚方法表`(Virtual Method Table)。虚方法表中存放着各个方法的实际入口地址。若某个方法在子类中没有被重写，则子类的虚方法表里面的地址入口指向父类的实现入口。方法表一般在类加载的连接阶段进行初始化，准备了类的变量初始值后，虚拟机会把该类的方法表也初始化完毕。
```



```shell
# 基于栈的字节码解释执行引擎
	Java语言中，Javac 编译器完成了程序代码经过词法分析、语法分析到抽象语法树，再遍历语法树生成线性的字节码指令流的过程。因为这一部分动作是在Java虚拟机之外进行的，而解释器发生在虚拟机的内部，所以Java程序的编译就是半独立的实现。
```



```shell
# 早期(编译期)优化
	Java语言的“编译期”其实是一段“不确定”的操作过程，因为它可能是指一个前端编译器把*.java文件转变成*.class文件的过程；也可能是指虚拟机的后端运行编译器(JIT编译器)把字节码转转变成及其嘛的过程；还可能是指使用静态提前编译器(AOT编译器)直接把*.java文件编译成本地机器码的过程；
	早期编译优化是指第一个过程：*.java  --->  *.class;
	语法糖(Syntactic Sugar)，也称糖衣语法，指在计算机语言中添加的某种语法，这种语法对语言的功能并没有影响，但是更方便程序员使用。
	# 语法糖1：泛型与类型擦除
		Java语言中的泛型只在程序源码中存在，在编译后的字节码文件中，就已经替换为原来的原生类型，并且在相应的地方插入了强制转型代码。因此，对于运行期的Java语言来说，ArrayList<Integer>与ArrayList<String>就是同一个类，所以泛型技术实际上是Java语言的一颗语法糖。Java语言中的泛型实现方法称为类型擦除，基于这种方法实现的泛型称为伪泛型。
	# 语法糖2：自动装箱、拆箱与循环遍历
		包装类的 "==" 运算在不遇到算数运算的情况下不会自动拆箱，以及他们的equals()方法不处理数据转型。
```



```shell
# 晚期(运行期)优化
	在部分的商用虚拟机中，Java程序最初是通过解释器(Interpreter)进行解释执行的，当虚拟机发现某个方法或代码块的运行特别频繁时，就会把这些代码认定为"热点代码"。为了提高热点代码的执行效率，在运行时，虚拟机将会把这些代码编译成与本地平台相关的机器码，并进行各种层次的优化，完成这个任务的编译器称为即时编译器(Just In Time Compiler)。
	解释器与编译器两者各有优势：当程序需要迅速启动和执行的时候，解释器可以首先发挥作用，省去编译的时间，立即执行。在程序运行后，随着时间的推移，编译器逐渐发挥作用，把越来越多的代码编译成本地代码之后，可以获取更高的执行效率。HotSpot虚拟机中内置了两个即时编译器，分别称为Client Compiler和Server Compiler，或者简称为C1编译器和C2编译器。目前主流的HotSpot虚拟机中，默认采用解释器与其中一个编译器直接配合的方式工作，在虚拟机中称为"混合模式(Mixed Mode)".
	在运行过程中会被即时编译器编译的"热点代码"有两类：
		1. 被多次调用的方法；
		2. 被多次执行的循环体，在方法执行过程中编译整个方法，称为栈上替换(On Stack Replacement,OSR编译)；
	虚拟机设计团队几乎把堆代码的所有优化措施都集中在了即时编译器之中，因此一般来说，即时编译器产生的本地代码比Javac产生的字节码更加优秀。
	代表性的优化技术：
		公共子表达式消除、数组边界检查消除、方法内联、逃逸分析
	逃逸分析：逃逸分析的基本行为就是分析对象动态作用域：当一个对象在方法中被定义后，它可能被外部方法所引用，例如作为调用参数传递到其他方法中，称为方法逃逸；甚至还有可能被外部线程访问到，譬如赋值给类变量或可以在其他线程中访问的实例变量，称为线程逃逸。
```













