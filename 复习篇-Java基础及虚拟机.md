# Java基础及虚拟机部分

## Part1：Java基础

### 1. Future 类

Future表示一个可能还没有完成的异步任务的结果，针对这个结果可以添加Callback以便在任务执行成功或失败后作出相应的操作。











## Part2：深入理解Java虚拟机

- JDK1.8默认垃圾回收器 Parallel Scavenge(新生代)+ Serial Old(老年代)；
- Windows默认虚拟机是Server模式；

```shell
# 抛出 OutOfMemoryError 异常
	1. 虚拟机栈动态扩展时无法申请到足够的内存，就会抛出 OOM 异常；
	2. 在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出 OutOfMemoryError 异常；
	3. 当方法区无法满足内存分配需求时，将抛出 OutOfMemoryError 异常；
	4. 运行时常量池无法申请到内存时会抛出 OOM 异常；
	5. 直接内存可能会导致各个内存区域总和大于物理内存限制(包括物理的和操作系统级的限制)，从而导致动态扩展时出现 OOM 异常；
```



```shell
# 对象的访问定位
# Sun HotSpot 虚拟机，是因为直接指针方式进行对象访问，好处就是速度快；
	1. 使用句柄
	  使用句柄访问，Java 堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。
	2. 直接指针
	  reference 中存储的直接就是对象地址。
```

![](D:\JAVA\Typora笔记\微信图片_20210116103728.jpg)

![](D:\JAVA\Typora笔记\微信图片_20210116103742.jpg)



```shell
# 垃圾收集的对象，确定哪些对象可以被回收
	1. 引用计数算法
		对象维护一个引用计数器，计数器值为0就是不会被使用的；问题：难以解决对象间循环引用的问题；
	2. 可达性分析算法(Reachability Analysis)
		通过一系列称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连时，证明此对象是不可用的。
		Java语言中，可作为GC Roots的对象包括下面几种：
		(对于一个 Java 程序而言，对象都位于堆内存块中，存活的那些对象都被根节点引用着，即根节点 GC Roots 是一些引用类型，自然不在堆里，是下面的)
			1. 虚拟机栈(栈帧中的本地变量表)中引用的对象；
			2. 方法区中类静态属性引用的对象；
			3. 方法区中常量引用的对象；
			4. 本地方法栈中JNI(即native方法)引用的对象；
		引用：
			强引用(Strong Reference):程序代码之中普遍存在的，类似“Object obj = new Object()”这类的引用，只要强引用还在，垃圾收集器永远不会回收掉被引用的对象；
			软引用(Soft Reference):用来描述一些有用但并非必需的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，会把这些对象列进回收范围之中进行第二次回收。
			弱引用(Weak Reference):描述非必需对象，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。
			虚引用(Phantom Reference):一个对象是否有虚引用的存在，完全不会对其生存时间构成影响。虚引用的唯一作用就是对象被收集器回收时收到一个系统通知。

# 回收方法区
	方法区(或者HotSpot虚拟机中的永久代)垃圾回收：废弃常量和无用的类。
		类需要同时满足下面三个条件才能算是“无用的类”：
			1. 该类的所有实例都已经被回收，即Java堆中不存在该类的任何实例；
			2. 加载该类的ClassLoader已经被回收；
			3. 该类对应的java.lang.Class对象没有在任何地方被引用，没有通过反射访问该类的方法；
```



```shell
# 垃圾收集算法
	1. 标记-清除算法(Mark-Sweep) --> 适用于老年代
		不足：1)效率问题，标记和清除两个过程的效率都不高；2)空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。
	2. 复制(Copying)算法 --> 适用于新生代
		将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor。当回收时，将Eden和Survivor中还存活着的对象一次性地复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。HotSpot虚拟机默认Eden和Survivor的大小比例是8:1。
	3. 标记-整理算法(Mark-Compact) --> 适用于老年代
		标记之后，所有存活的对象向一端移动，再直接清理掉端边界以外的内存。
```



```shell
# HotSpot 发起内存回收
	GC 进行时必须停顿所有Java执行进程来保证“一致性”(Sun 将这件事情称为 Stop The World)。HotSpot通过一组OopMap的数据结构来拿到对象引用，即HotSpot在OopMap的协助下，可以快速且准确地完成GC Roots枚举。程序执行只有到安全点(SafePoint)的位置才可以停顿下来开始GC，当GC需要中断线程的时候，采用主动式中断，各个线程主动去轮询中断标志，中断标志位真时挂起线程。轮询标志的地方有安全点、创建对象需要分配内存的地方。当程序不执行(例如线程处于Sleep或者Blocked状态)，使用安全区域(Safe Region)来解决。
	一致性：整个分析GC Roots期间，执行系统全部停顿，对象引用关系不发生变化。
	OopMap：从外部记录下栈里Reference类型变量的类型信息，存成一个映射表。
```



```shell
# HotSpot虚拟机中的垃圾收集器
虚拟机server模式:启动慢，编译更完全，编译器是自适应编译器，效率高，针对服务端应用优化，在服务器环境中最大化程序执行速度而设计。
虚拟机client模式:快速启动，内存占用少，编译快，针对桌面应用程序优化，为在客户端环境中减少启动时间而优化；
当JVM用于启动GUI界面的交互应用时适合于使用client模式，当JVM用于运行服务器后台程序时建议用Server模式。
	1. Serial收集器  --> 新生代收集器(复制算法)
		1)使用一个CPU或者一条收集线程去完成垃圾收集工作；
		2)垃圾收集时必须暂停其他所有的工作线程，直到收集结束。
		Serial收集器是虚拟机运行在Client模式下的默认新生代收集器。
	2. ParNew收集器  --> 新生代收集器(多线程复制算法)
		Serial收集器的多线程版本，使用多条线程并行进行垃圾收集；
		可以与CMS收集器配合工作；
		ParNew收集器是虚拟机运行在Server模式下首选的新生代收集器。
	3. Parallel Scavenge收集器  --> 新生代收集器(多线程复制算法)
		Parallel Scavenge收集器的目标是达到一个可控制的吞吐量。
	4. Serial Old收集器  --> 老年代收集器(单线程标记-整理算法)
		Serial Old是Serial收集器的老年代版本，单线程收集器，标记-整理算法；
		Client模式下的虚拟机使用；
	5. Parallel Old收集器  --> 老年代收集器(多线程标记-整理算法)
		Parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程和标记-整理算法；
		“吞吐量优先”收集器组合：Parallel Scavenge 和 Parallel Old收集器；
	6. CMS(Concurrent Mark Sweep)收集器  --> 老年代收集器(标记-清除算法)
		CMS收集器是一种以获取最短回收停顿时间为目标的收集器。CMS收集器回收老年代基于标记-清除算法，收集过程如下：
		1)初始标记(需要Stop The World)：初始标记仅仅只是标记一下GC Roots能直接关联到的对象，速度很快；
		2)并发标记：进行GC Roots Tracing的过程；
		3)重新标记(需要Stop The World)：修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，停顿时间比初始标记阶段长一些；
		4)并发清理
		CMS收集器的缺点：对CPU资源敏感、无法处理浮动垃圾、标记-清理算法的空间碎片；
		“浮动垃圾”：程序运行的垃圾在标记过程结束后产生，CMS无法在当次收集中处理只能留到下一次GC，即浮动垃圾
	7. G1收集器(Garbage-First)  -->面向服务端应用(新生代+老年代)
	  G1收集器特点：
	    并行与并发、空间整合(整体上标记-清理算法，两个Region复制算法)、可预测的停顿、分代收集
	    分代收集：独立管理整个堆，采用不同的方式去处理新创建的对象和已经存活了一段时间、熬过多次GC的旧对象； 
	  G1收集器运行过程：G1收集器将整个Java堆划分为多个大小相等的独立区域(Region)，新生代和老年代不再是物理隔离的，都是一部分Region(不需要连续)的集合，G1跟踪各个Region里面的垃圾堆积的价值大小，在后台维护一个优先列表，每次根据允许的回收时间，优先回收价值最大的Region。
	  在G1收集器中，Region之间的对象引用以及其他收集器中的新生代与老年代之间的对象引用，虚拟机都是使用Remember Set来避免全堆扫描的。
	  G1收集器回收过程：
	  初始标记阶段：标记GC Roots能直接关联到的对象，并且修改TAMS(Next Top at Mark Start)的值，让下一阶段用户程序并发运行时，能在正确可用的Region中创建新对象，这一阶段需要停顿，但耗时很短。
	  并发标记阶段：从GC Roots开始对堆中对象进行可达性分析，找出存活的对象，这阶段一般较长，但可以与用户程序并发执行；
	  最终标记阶段：为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，这一阶段需要停顿线程，可以并行执行；
	  筛选回收阶段：对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间来制定回收计划，可以并行执行；
```



```shell
# 内存分配与回收策略
	Java技术体系中所提倡的自动内存管理最终可以归结为自动化地解决了两个问题：给对象分配内存以及回收分配给对象的内存。对象的内存分配就是在堆(Java Heap)上分配，对象主要分配在新生代的Eden区，如果开启了本地线程分配缓存，将按线程优先在TLAB上分配。
	内存分配策略(Serial/Serial Old收集器)：对象优先在Eden分配、大对象直接进入老年代(大量连续空间)、长期存活的对象进入老年代(超过新生代年龄阈值)、动态对象年龄判定(Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于等于该年龄的对象就可以直接进行老年代)、空间分配担保(之前每次回收晋升到老年代对象容量的平均大小作为担保)
```



```shell
# 垃圾收集器中的并发和并行
	并行(Parallel)：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态；
	并发(Concurrent)：指用户线程与垃圾收集线程同时执行(但不一定是并行的，可能会交替执行)，用户程序在继续运行，而垃圾收集程序运行于另一个CPU上。
# 吞吐量：CPU用于运行用户代码的时间与CPU总消耗时间的比值；
# Minor GC 和 Full GC
新生代GC(Minor GC)：指发生在新生代的垃圾收集动作；
老年代GC(Major GC/Full GC)：指发生在老年代的GC，Full GC的速度一般会比Minor GC慢10倍以上；

# 触发MinorGC(Young GC)
    虚拟机在进行minorGC之前会判断老年代最大的可用连续空间是否大于新生代的所有对象总空间
    1、如果大于的话，直接执行minorGC
    2、如果小于，判断是否开启HandlerPromotionFailure，没有开启直接FullGC
    3、如果开启了HanlerPromotionFailure, JVM会判断老年代的最大连续内存空间是否大于历次晋升的大小，如果小于直接执行FullGC
    4、如果大于的话，执行minorGC
    对于HandlerPromotionFailure，我们可以这样理解，在发生Minor GC之前，虚拟机会先检查老年代的最大的连续内存空间是否大于新生代的所有对象的空间，如果这个条件成立，Minor GC是安全的。如果不成立虚拟机会查看HanlerPromotionFailure 设置值是否允许担当失败，如果允许，那么会继续检查老年代最大可用的连续内存空间是否大于历次晋级到老年代对象的平均大小，如果大于就尝试一次Minor GC， 如果小于，或者HanlerPromotionFailure 不愿承担风险就要进行一次Full GC。
# 触发FullGC
	1)老年代空间不足:如果创建一个大对象，Eden区域当中放不下这个大对象，会直接保存在老年代当中，如果老年代空间也不足，就会触发Full GC。为了避免这种情况，最好就是不要创建太大的对象。
	2)持久代空间不足:如果有持久代空间的话，系统当中需要加载的类，调用的方法很多，同时持久代当中没有足够的空间，就出触发一次Full GC。
	3)YGC出现promotion failure:promotion failure发生在Young GC, 如果Survivor区当中存活对象的年龄达到了设定值，会就将Survivor区当中的对象拷贝到老年代，如果老年代的空间不足，就会发生promotion failure， 接下去就会发生Full GC。
	4)统计YGC发生时晋升到老年代的平均总大小大于老年代的空闲空间:在发生YGC是会判断，是否安全，这里的安全指的是，当前老年代空间可以容纳YGC晋升的对象的平均大小，如果不安全，就不会执行YGC,转而执行Full GC。
	5)显示调用System.gc
```



```shell
# Class 类文件的结构
	Class 文件是一组以8位字节为基础的二进制流，各个数据项目严格按照顺序紧凑地排列在Class文件中，中间没有添加任何分隔符，这使得整个Class文件中存储的内容几乎全部是程序运行的必要数据，没有空隙存在。当遇到需要占用8位字节以上空间的数据项时，则会按照高位在前的方式分割成若干个8位字节进行存储。
	Class文件格式中存在两种数据类型：无符号数和表；无符号数属于基本的数据类型，无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串。表示由多个无符号数或者其他表作为数据项构成的复合数据类型。
#  Class 类文件结构：
	1. 头4个字节：魔数(Magic Number),值为：0xCAFEBABE，标识能否被虚拟机接受;
	2. 第5、6个字节：次版本号
	3. 第7、8个字节：主版本号
	4. 常量池：
		常量池可以理解为class文件之中的资源仓库，常量池入口是一个u2类型的数据，代表常量池容量计数值(constant_pool_count),容量计数是从1开始，例如常量池容量为22，则常量池索引为1~21.Class文件中第0项常量空出来是为了满足后面某些指向常量池的索引值的数据在特定情况下需要表达“不引用任何一个常量池项目”的含义。
		常量池中主要存放两大类常量：字面量(Literal)和符号引用(Symbolic Reference)。符号引用包括：类和接口的全限定名(Fully Qualified Name)、字段的名称和描述符(Descriptor)和方法的名称和描述符。
		特殊记忆：字符串最大长度：64KB(65535)，CONSTANT_Utf8_info型常量(UTF-8缩略编码)的结构：u1 tag --->  u2 length  ---> u1 bytes(数量：bytes)；由于Class文件中方法、字段等都需要引用CONSTANT_Utf8_info型常量来描述名称，所以CONSTANT_Utf8_info型常量的最大长度也就是Java方法中方法、字段名的最大长度。而这里的最大长度就是length的最大值，即u2类型能表达的最大值65535.所以Java程序中如果定义了超过64KB英文字符的变量或方法名，将会无法编译。
	5. 访问标志(类或者接口层次的访问信息)
	6. 类索引、父类索引和接口索引集合
	7. 字段表集合
		字段表(field_ininfo)用于描述接口或者类中声明的变量。字段(field)包括类级变量以及实例级变量(是否被static修饰)，但不包括在方法内部声明的局部变量。字段表集合中不会列出从超类或者父接口中继承而来的字段。
	8. 方法表集合
		若父类方法在子类中没有被重写(Override)，方法集合中就不会出现来自父类的方法信息。
	9. 属性表集合
		在Class文件、字段表、方法表都可以携带自己的属性表集合，以用于描述某些场景专有的信息。
		Code属性：如果把Java程序中的信息分为代码(Code,方法体里面的Java代码)和元数据(Metadata，包括类、字段、方法定义及其他信息)，那么在整个class文件中，Code属性用于描述代码，所有的其他数据项目都用于描述元数据。
		任何实例方法里面 ，都可以通过this关键字来访问到此方法所属的对象(方法参数至少有一个this)。这个访问机制对Java程序的编写很重要，实现的时候通过javac编译器编译的时候，把对this关键字的访问转变为对一个普通方法参数的访问，然后虚拟机调用实例方法的时自动传入此参数即可。在实例的局部变量表中第0位索引的slot用于传递方法所属对象实例的引用，在方法中可以通过关键字this访问到这个隐含的参数。
```



```shell
# 字节码指令简介
	大多数对于boolean、byte、short和char类型数据的操作，实际上都是使用相应的int类型作为运算类型。
	Java虚拟机直接支持一下数据类型的宽化类型转换：
		1. int类型到long、float或者double类型；
		2. long类型到float、double类型；
		3. float类型到double类型；
```



```shell
# 虚拟机类加载机制
	# 概述
		虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。
		在Java语言中，类型的加载、连接和初始化过程都是在程序运行期间完成的。Java里天生可以动态扩展的语言特性就是依赖运行期动态加载和动态连接这个特点实现的。
	# 类加载的时机
		主动引用：虚拟机规范规定有且只有5种情况必须对类进行“初始化”
			1. 遇到new、getstatic、putstatic、或invokestatic这4条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。生成这4条指令的最常见的Java代码场景是：使用new关键字实例化对象的时候，读取或设置一个类的静态字段(被final修饰，已在编译期把结果放入常量池的静态的字段除外)的时候，以及调用一个类的静态方法的时候。
			2. 使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。
			3. 当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。
			4. 当虚拟机启动时，用户需要指定一个要执行的主类(包含main()方法的那个类)，虚拟机会先初始化这个主类。
			5. 当使用动态语言支持时，若java.lang.invoke.MethodHandle实例最后的解析结果的方法句柄，且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化。
		被动引用：除了上述5种主动引用类的方法外，所有引用类的方法都不会触发初始化；
			1. 通过子类引用父类的静态字段，不会导致子类初始化。对于静态字段，只有直接定义这个字段的类才会被初始化。
			2. 通过数组定义来引用类，不会触发此类的初始化。例：SuperClass[] sca = new SuperClass[10], 不会导致SuperClass类的初始化。
			3. 常量(final修饰)在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。
		接口主动引用与类主动引用的区别：
			接口与类真正有所区别的是初始化场景中的第3种：一个接口在初始化时，并不要求其父接口全部都完成了初始化，只有在真正使用到父接口的时候(如引用接口中定义的常量)才会初始化。
```



 ```shell
# 类加载的过程
	1.加载，在加载阶段，虚拟机需要完成以下3件事情：
		1)通过一个类的全限定名来获取定义此类的二进制字节流；
		2)将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构；
		3)在内存中生成一个代表这个类的java.lang.Class对象(HotSpot虚拟机存放在方法区中)，作为方法区这个类的各种数据的访问入口。
		数组类本身不通过类加载器创建，它是由Java虚拟机直接创建的，一个数组类创建过程：如果数组的组件类型是引用类型，就递归加载过程去加载组件类型，数组C将在加载该组件类型的类加载器的类名称空间上被表示；若数组的组件类型不是引用类型，Java虚拟机将会把数组C标记为与引导类加载器关联；数组类的可见性与它的组件类型的可见性一致，若组件类型不是引用类型则数组类的可见性默认为public。
	2. 验证(连接阶段第一步)
		验证阶段大致上会完成下面4个阶段的检验动作：文件格式验证、元数据验证、字节码验证、符号引用验证。
	3. 准备(连接阶段第二步)
		准备阶段是正式为类变量分配内存并设置类变量(static修饰的变量)初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。
	4. 解析(连接阶段第三步)
		解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。
		符号引用(Symbolic Reference):符号引用一一组符号来描述所引用的目标。
		直接引用(Direct Reference):直接引用可以使直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。除invokedynamic指令外，虚拟机实现可以对第一次解析的结果进行缓存从而避免解析动作重复进行。
		1)类或接口的解析：当前代码在类D，未解析过的符号N指向类或接口C的直接引用过程：若C不是一个数组类型，则将代表N的全限定名传给类D的类加载器去加载类C；若C是一个数组类型，且数组的元素类型是对象，则先加载数组元素类型，再由虚拟机生成代表数组维度和元素的数组对象。
		2)字段解析：解析字段所属的类或接口 --> 字段属于C --> 自下向上递归搜索接口和父接口是否有该字段 --> 自下向上递归搜索父类是否有该字段；
		3)类方法解析：方法 --> 解析属于C --> 递归解析父类 --> 递归解析父接口
		4)接口方法解析：方法 --> 解析属于接口C ---> 递归解析父接口
	5. 初始化
		初始化阶段是执行类构造器<clinit>()方法的过程，<clinit>()方法特点：
		1)<clinit>()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块(static{}块)中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在静态语句块之后的变量，在前面的静态语句块中可以赋值，但是不能访问。
		2)<clinit>()方法与类的构造函数(或者说实例构造器<init>()方法)不同，不需要显式地调用父类构造器，虚拟机会保证在子类的<clinit>()方法执行前，父类的<clinit>()方法已经执行完毕。因此在虚拟机中第一个被执行的<clinit>()方法的类肯定是java.lang.Object。
		3)由于父类的<clinit>()方法先执行，也就意味着父类中定义的静态语句块要优先于子类的变量赋值操作；
		4)<clinit>()方法对于类或接口来说不是必需的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成<clinit>()方法；
		5)接口(在interface里面的变量都是public static final的)的<clinit>()方法不需要先执行父接口的<clinit>()方法，只有当父接口中定义的变量使用时，父接口才初始化；
		6)虚拟机会保证一个类的<clinit>()方法在多线程环境中被正确地加速、同步，多个线程同时初始化一个类，只有一个线程执行类的<clinit>()方法，其余线程阻塞等待。
 ```



```shell
# 类加载器
	虚拟机设计团队把类加载阶段中的“通过一个类的全限定名来获取描述此类的二进制字节流”这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需要的类，实现这个动作的代码模块称为“类加载器”；
	对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性。
	#  双亲委派模型
		从虚拟机角度来讲，只存在两种不同的类加载器：一种是启动类加载器(Bootstrap ClassLoader)，这个类加载器使用C++语言实现，是虚拟机自身的一部分；另一种就是所有其他的类加载器，这些类加载器都由Java语言实现，独立于虚拟机外部，并且全部都继承自抽象类java.lang.ClassLoader；
		从开发人员的角度来看，绝大部分Java程序都会用到以下3种系统提供的类加载器：
			1. 启动类加载器(BootStrap ClassLoader)：存放在<JAVA_HOME>\lib目录中的，并且是虚拟机识别的类库加载到虚拟机内存中；
			2. 扩展类加载器(Extension ClassLoader):存放在<JAVA_HOME>\lib\ext目录指定的路径中的所有类库；
			3. 应用程序类加载器(Application ClassLoader): 系统类加载器，负责加载用户类路径(ClassPath)上所指定的类库，一般情况下程序中默认使用应用程序类加载器；
	类加载器的双亲委派模型：
```

![image-20210120175957286](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210120175957286.png)

```shell
# 类加载器的双亲委派模型(Parents Delegation Model)
	双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。这里类加载器的父子关系使用组合(Composition)关系来复用父加载器的代码(组合自己理解就是子类加载器LoadClass方法中组合对父类加载器的使用)。
	双亲委派模型的工作过程是：如果一个类加载器收到了类加载请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此。因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求时，子加载器才会尝试自己去加载。
	双亲委派模型的代码逻辑：实现双亲委派模型的方法在ClassLoader类中的loadClass()方法中：先检查是否已经被加载过，若没有加载则调用父加载器的loadClass()方法，若父加载器为空则默认使用启动类加载器作为父加载器；若父类加载失败，抛出ClassNotFoundException异常后，再调用自己的findClass()方法进行加载。
    # 破坏双亲委派模型
    	线程上下文类加载器(Thread Context ClassLoader);
    	OSGi 环境下，类加载器不再是双亲委派模型中的树状结构，而是进一步发展为更加复杂的网状结构；
```

```java
protected Class<?> loadClass(String name, boolean resolve)
        throws ClassNotFoundException
    {
        synchronized (getClassLoadingLock(name)) {
            // First, check if the class has already been loaded
            Class<?> c = findLoadedClass(name);
            if (c == null) {
                long t0 = System.nanoTime();
                try {
                    if (parent != null) {
                        // 父类加载器
                        c = parent.loadClass(name, false);
                    } else {
                        // 启动类加载器
                        c = findBootstrapClassOrNull(name);
                    }
                } catch (ClassNotFoundException e) {
                    // ClassNotFoundException thrown if class not found
                    // from the non-null parent class loader
                }

                if (c == null) {

                    long t1 = System.nanoTime();
                    // 本身的findClass()方法进行类加载
                    c = findClass(name);

                    // this is the defining class loader; record the stats
                    sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);
                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);
                    sun.misc.PerfCounter.getFindClasses().increment();
                }
            }
            if (resolve) {
                resolveClass(c);// 连接操作，native方法
            }
            return c;
        }
    }
```



  ```shell
# 虚拟机字节码执行引擎
	在不同的虚拟机实现里面，执行引擎在执行Java代码的时候可能会有解释执行(通过解释器执行)和编译执行(通过即时编译器产生本地代码)两种选择。
	# 运行时栈帧结构
		栈帧(Stack Frame)是用于支持虚拟机进行方法调用和方法执行的数据结构，它是虚拟机运行时数据区中的虚拟机栈(Virtual Machine Stack)的栈元素。每一个栈帧都包括了局部变量表、操作数栈、动态连接、方法返回地址和一些额外的附加信息。每一个方法从调用开始至执行完成的过程，都对应看一个栈帧在虚拟机栈里面从入栈到出栈的过程。
		1. 局部变量表(Local Variable Table)
			局部变量表示一组变量存储空间，用于存放方法参数和方法内部定义的局部变量。局部变量表的容量以变量槽(Variable Slot)为最小单位。在方法执行时，虚拟机使用局部变量表完成参数值到参数变量表的传递过程。若执行的是实例方法，则局部变量表中的第0位索引的Slot默认是用于传递方法所属对象实例的引用，在方法中可以通过关键字"this"来访问到这个隐含的参数，其余参数则按照参数表顺序排序，占用从1开始的局部变量Slot。
			类变量有两次赋初始值过程：第一次是在类加载过程中的准备阶段，赋予系统初始值；第二次是在初始化阶段，赋予程序员定义的初值。因此，即使在初始化阶段程序员没有为类变量赋值也没有关系，类变量仍然具有一个确定的初始值。但局部变量就不一样，如果一个局部变量定义了但是没有赋初始值是不能使用的。
		2. 操作数栈(Operand Stack)
			操作数栈也称为操作栈，它是一个先入后出栈(First In Last Out)。当一个方法刚开始执行的时候，方法的操作数栈是空的，在方法的执行过程中，会有各种字节码指令往操作数栈中写入和提取内容，即入栈和出栈操作。在大多数虚拟机的实现中，下面栈帧的操作数栈与上面栈帧的局部变量表重叠在一起，这样在进行方法调用时就可以共用一部分数据，无需进行额外的参数复制传递。Java虚拟机的解释执行引擎称为“基于栈的执行引擎”，该栈就是操作数栈。
		3. 动态连接(Dynamic Linking)
			静态解析、动态连接
		4. 方法返回地址
  ```



```shell
# 方法调用
  方法调用阶段的唯一任务就是确定被调用方法的版本。所有方法调用中的目标方法在Class文件里面都是一个常量池中的符号引用。
  # 解析(类加载的解析阶段)(Resolution)
  	在类加载的解析阶段，会将其中的一部分符号引用转化为直接引用，这种解析能成立的前提是：调用目标在程序代码写好、编译器进行编译时就必须确定下来，这类方法的调用称为解析。在Java语言中符合“编译期可知，运行期不变”这个要求的方法，主要包括静态方法和私有方法两大类。
  	在类加载的解析阶段符合条件的有：静态方法、私有方法、实例构造器、父类方法和final修饰的方法，这些方法又称为非虚方法，在类加载的时候就会把符号引用解析为直接引用(内存布局中的入口地址)。
  	解析调用定义时一个静态的过程，在编译期间就完全确定，在类装载的解析阶段就会把涉及的符号引用全部转变为可确定的直接引用，不会延迟到运行期再去完成。
  # 分派
  	1. 静态分派(编译阶段)
  	Human man = new Man(); "Human"称为变量的静态类型，"Man"称为变量的实际类型。
  		所有依赖静态类型来定位方法执行版本的分派动作称为静态分派。静态分派的典型应用是方法重载(Overload)。静态分派发生在编译阶段；编译器在重载时通过参数的静态类型而不是实际类型作为判定依据的，并且静态类型是编译期可知。
  	2. 动态分派(运行阶段，invokevirtual指令)
  		动态分派和多态性的另外一个体现：重写(Override)关联。把在运行期根据实际类型确定方法执行版本的分派过程称为动态分派。
  		将要执行方法的所属对象，称为接收者(Receiver)；invokevirtual指令的多态查找过程，invokevirtual指令用于调用对象的实例方法，该指令的运行时解析过程：
  		1) 找到操作数栈顶的第一个元素所指向的对象的实际类型，记作C；
  		2) 如在类C中找到与常量中的描述符和简单名称都相符的方法，则进行访问权限校验，通过则直接返回这个方法的直接引用，查找过程结束；否则，返回 java.lang.IllegalAccessError异常；
  		3) 否则，按照继承关系从下往上依次对C的各个父类进行第2步的搜索和验证过程；
  		4) 始终没有找到合适的方法，则抛出 java.lang.AbstractMethodError 异常；
  		由于 invokevirtual 指令执行的第一步就是在运行期确定接收者的实际类型，所以调用过程中的 invokevirtual 指令把常量池中的类方法符号引用解析到了不同的直接引用上，这个过程就是Java语言方法重写的本质(Override)。
  	3. 单分派与多分派
  		方法的接收者与方法的参数统称为方法的宗量。
  		Java代码编译阶段：静态分派属于多分派类型；
  		Java运行阶段：动态分派属于单分派类型；
  # 虚拟机动态分派的实现
  	最常用的“稳定优化”手段就是为类在`方法区`中建立一个`虚方法表`(Virtual Method Table)。虚方法表中存放着各个方法的实际入口地址。若某个方法在子类中没有被重写，则子类的虚方法表里面的地址入口指向父类的实现入口。方法表一般在类加载的连接阶段进行初始化，准备了类的变量初始值后，虚拟机会把该类的方法表也初始化完毕。
```



```shell
# 基于栈的字节码解释执行引擎
	Java语言中，Javac 编译器完成了程序代码经过词法分析、语法分析到抽象语法树，再遍历语法树生成线性的字节码指令流的过程。因为这一部分动作是在Java虚拟机之外进行的，而解释器发生在虚拟机的内部，所以Java程序的编译就是半独立的实现。
```



```shell
# 早期(编译期)优化
	Java语言的“编译期”其实是一段“不确定”的操作过程，因为它可能是指一个前端编译器把*.java文件转变成*.class文件的过程；也可能是指虚拟机的后端运行编译器(JIT编译器)把字节码转转变成及其嘛的过程；还可能是指使用静态提前编译器(AOT编译器)直接把*.java文件编译成本地机器码的过程；
	早期编译优化是指第一个过程：*.java  --->  *.class;
	语法糖(Syntactic Sugar)，也称糖衣语法，指在计算机语言中添加的某种语法，这种语法对语言的功能并没有影响，但是更方便程序员使用。
	# 语法糖1：泛型与类型擦除
		Java语言中的泛型只在程序源码中存在，在编译后的字节码文件中，就已经替换为原来的原生类型，并且在相应的地方插入了强制转型代码。因此，对于运行期的Java语言来说，ArrayList<Integer>与ArrayList<String>就是同一个类，所以泛型技术实际上是Java语言的一颗语法糖。Java语言中的泛型实现方法称为类型擦除，基于这种方法实现的泛型称为伪泛型。
	# 语法糖2：自动装箱、拆箱与循环遍历
		包装类的 "==" 运算在不遇到算数运算的情况下不会自动拆箱，以及他们的equals()方法不处理数据转型。
```



```shell
# 晚期(运行期)优化
	在部分的商用虚拟机中，Java程序最初是通过解释器(Interpreter)进行解释执行的，当虚拟机发现某个方法或代码块的运行特别频繁时，就会把这些代码认定为"热点代码"。为了提高热点代码的执行效率，在运行时，虚拟机将会把这些代码编译成与本地平台相关的机器码，并进行各种层次的优化，完成这个任务的编译器称为即时编译器(Just In Time Compiler)。
	解释器与编译器两者各有优势：当程序需要迅速启动和执行的时候，解释器可以首先发挥作用，省去编译的时间，立即执行。在程序运行后，随着时间的推移，编译器逐渐发挥作用，把越来越多的代码编译成本地代码之后，可以获取更高的执行效率。HotSpot虚拟机中内置了两个即时编译器，分别称为Client Compiler和Server Compiler，或者简称为C1编译器和C2编译器。目前主流的HotSpot虚拟机中，默认采用解释器与其中一个编译器直接配合的方式工作，在虚拟机中称为"混合模式(Mixed Mode)".
	在运行过程中会被即时编译器编译的"热点代码"有两类：
		1. 被多次调用的方法；
		2. 被多次执行的循环体，在方法执行过程中编译整个方法，称为栈上替换(On Stack Replacement,OSR编译)；
	虚拟机设计团队几乎把堆代码的所有优化措施都集中在了即时编译器之中，因此一般来说，即时编译器产生的本地代码比Javac产生的字节码更加优秀。
	代表性的优化技术：
		公共子表达式消除、数组边界检查消除、方法内联、逃逸分析
	逃逸分析：逃逸分析的基本行为就是分析对象动态作用域：当一个对象在方法中被定义后，它可能被外部方法所引用，例如作为调用参数传递到其他方法中，称为方法逃逸；甚至还有可能被外部线程访问到，譬如赋值给类变量或可以在其他线程中访问的实例变量，称为线程逃逸。
```



### Java内存模型与线程

- 一个服务端同时对多个客户端提供服务。衡量一个性能的高低好坏，每秒事务处理数(Transactions Per Second, TPS)是衡量指标之一。
- 由于计算机的存储设备与处理器的运算速度有几个数量级的差距，所以现代计算机系统都不得不加入一层读写速度尽可能接近处理器运算速度的高速缓存(Cache)来作为内存与处理器之间的缓冲。但缓存带来了更为复杂的问题：**缓存一致性**

#### Java内存模型(Java Memory Model, JMM)

- Java内存模型的主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。此处的变量包括实例字段、静态字段和构成数组对象的元素，但不包括局部变量与方法参数，因为后者是线程私有的，不会被共享不存在竞争问题。

- Java内存模型规定了所有的变量都存储在主内存(虚拟机主内存)(Main Memory)中，每条线程还有自己的工作内存(虚拟机工作内存)(Working Memory)，线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存中的变量(volatile变量依然有工作内存的拷贝)。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成。

```shell
# Java 内存模型中定义了以下8种操作来完成，虚拟机实现时必须保证下面提及的每一种操作都是原子的、不可再分的：
  1. lock(锁定)：作用于`主内存的变量`，把一个变量标识为一条线程独占的状态；
  2. unlock(解锁)：作用于`主内存的变量`，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定
  3. read(读取)：作用于`主内存的变量`，把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用
  4. load(载入)：作用于`工作内存的变量`，把read操作从主内存中得到的变量值放入工作内存的变量副本中
  5. use(使用)：作用`工作内存的变量`，把工作内存中一个变量的值传递给执行引擎
  6. assign(赋值)：作用于`工作内存的变量`，把一个从执行引擎接收到的值传递给工作内存中的变量；
  7. store(存储)：作用于`工作内存的变量`，把工作内存中的一个变量的值传送到主内存中，供随后的write操作使用
  8. write(写入)：作用于`主内存的变量`，把store操作从工作内存中得到的变量的值放入主内存中的变量中
 对一个变量执行lock操作，清空工作内存中此变量的值，执行引擎使用这个变量前，需要重新执行load或assign操作初始化变量的值。对一个变量执行unlock操作之前，必须先把此变量同步回主内存中。
```



#### volatile型变量的特殊规则

当一个变量定义为`volatile`之后，它将具备两种特性：

- 1  保证此变量对所有线程的可见性：“可见性”是指当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的，而普通变量的值在线程间传递需要通过主内存来完成。volatile变量每次使用前都需要先刷新，所以`volatile`变量对所有线程是立即可见的；
- 2  禁止指令重排序优化：有`volatile`修饰的变量，赋值后多执行了一个`lock addl $0x0`操作，这个操作相当于一个内存屏障(Memory Barrier 或 Memory Fence, 指重排序时不能把后面的指令重排序到内存屏障之前的位置)。`lock`前缀的作用是使得本CPU的Cache写入内存同时该写入动作也会引起别的CPU或者别的内核无效化其Cache，所以在使用该变量时需要刷新；可以使得volatile变量的修改对其他CPU立即可见。

```shell
# volatile 关键字的运用场景：
	由于volatile变量只能保证可见性，除了一下两条规则的运算场景，需要通过加锁(使用synchronized或java.util.concurrent中的原子类)来保证原子性：
	1. 运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值；
	2. 变量不需要与其他的状态量共同参与不变约束；
```

```shell
# Java 内存模型中对volatile变量定义的特殊规则：
	1. read --> load --> use 动作连续出现
		这条规则要求在工作内存中，每次使用变量前都必须先从主内存刷新最新的值，用于保证能看见其他线程对变量所做的修改后的值；
	2. assign --> store --> write 动作连续出现
		这条规则要求在工作内存中，每次修改后都必须立刻同步回主内存中，用于保证其他线程可以看到自己对变量所做的修改
	3.  若A动作先于B动作，则A结束的动作先于B结束的动作
		这条规则要求volatile修饰的变量不会被指令重排序优化，保证代码的执行顺序与程序的顺序相同。
```



#### 原子性、可见性与有序性

- **原子性(Atomicity)**：由Java内存模型来直接保证的原子性变量操作包括：read、load、assign、use、store和write，基本数据类型的访问读写是具备原子性的；`synchronized`块之间的操作也具备原子性，字节码指令：monitorenter和monitorexit；
- **可见性(Visibility)**：可见性是指当一个线程修改了共享变量的值，其他线程能够立即得知这个修改。Java内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介的方式来实现可见性的；`volatile`的特殊规则保证了新值能立即同步到主内存，以及每次使用前立即从主内存刷新。此外`synchronized`和`final`关键字也可以实现可见性。
- **有序性(Ordering)**：Java程序中天然的有序性可以总结为一句话：如果在本线程内观察，所有的操作都是有序的，如果在一个线程中观察另一个线程，所有的操作都是无序的。前半句是指线程内表现为串行的语义，后半句是指指令重排序和工作内存与主内存同步延迟现象；Java语言提供了`volatile`和`synchronized`两个关键字来保证线程之间操作的有序性。



#### 先行发生原则

- Java语言中有一个“先行发生”(happens - before)原则，判断数据是否存在竞争、线程是否安全的主要依据；先行发生是Java内存模型定义的两项操作之间的偏序关系，若操作A先行发生于操作B，其实就是发生操作B之前，操作A产生的影响能被操作B观察到。
- 先行发生关系：程序次序规则、管程锁定规则、volatile变量规则、线程启动规则、线程终止规则、线程中断规则、对象终结规则、传递性；
- 注意：时间先后顺序与先行发生原则之间基本没有太大的关系，所以衡量并发安全问题的时候不要受到时间顺序的干扰，一切必须以先行发生原则为准。



#### 线程的实现

线程的引入，可以把一个进程的资源分配和执行调度分开，各个线程既可以共享进程资源(内存地址、文件I/O等)，又可以独立调度(线程是CPU调度的基本单位)，线程的实现主要有以下三种方式：

- **使用内核线程实现**：内核线程(Kernnel - Level Thread, KLT)就是直接由操作系统内核支持的线程，由内核来完成切换；程序使用内核线程的一种高级接口——轻量级进程(Light  Weight  Process, LWP)，轻量级进程就是线程；这种轻量级进程与内核线程1 ： 1的关系称为**一对一的线程模型**；缺点：系统调用存在用户态和内核态，消耗一定的内存资源；一个系统支持轻量级进程的数量是有限的；
- **使用用户线程实现**：用户线程的建立、同步、销毁和调度完全在用户态中完成，不需要内核的帮助。如果程序实现的得当，这种线程不需要切换到内核态，因此操作可以是快速且低消耗的；这种进程与用户线程1 ： N的关系称为**一对多的线程模型**；
- **使用用户线程加轻量级进程混合实现**：混合模式中，用户线程与轻量级进程的数量比是不定的，即为 N ： M的关系；

对于Sun JDK来说，Windows版与Linux版都是使用一对一的线程模型实现的，一条Java进程就映射到一条轻量级进程之中，因为Windows和Linux系统提供的线程模型就是一对一的。Java线程调度使用**抢占式线程调度**。



#### Java线程状态

wait() 方法放弃对象锁，sleep() 方法不放弃对象锁；

在任意一个时间点，一个线程只能有且只有其中的一种状态：

- 新建(New)：创建后尚未启动的线程处于新建状态；
- 运行(Runnable)：Runnable 包括了操作系统进程状态中的Running和Ready，也就是处于此状态的线程有可能正在执行，也有可能正在等待着CPU为它分配执行时间；
- 无限期等待(Waiting)：处于这种状态的线程不会被CPU分配执行时间，需要等待其他线程**显式**地唤醒：没有设置TimeOut参数的Object.wait() 方法、没有设置TimeOut参数的Thread.join() 方法、LockSupport.park()方法；
- 限期等待(Timed Waiting)：处于这种状态的线程也不会被分配CPU执行时间，在一定时间之后由系统自动唤醒：Thread.sleep() 方法、设置了TimeOut参数的Object.wait() 方法、设置了TimeOut参数的Thread.join() 方法、LockSupport.parkNanos()/LockSupport.parkUntil() 方法
- 阻塞(Blocked)：线程被阻塞，阻塞状态等待着获取一个排他锁，这个时间将在另外一个线程放弃这个锁的时候发生；在程序进入同步区域的时候，线程将进入这种状态；
- 结束(Treminated)：已经终止线程的线程状态，线程已经结束执行；



### 线程安全与锁优化

 ```shell
#  面向对象与面向过程
	面向过程的编程思想：程序编写以算法为核心，程序员会把数据和过程分别作为独立的部分来考虑，数据代表问题空间中的客体，程序代码则用于处理这些数据，这种思维直接站在计算机的角度去抽象问题和解决问题，称为面向过程的编程思想。与此相对的是，面向对象的编程思想是站在现实世界的角度去抽象和解决问题，把数据和行为都看做是对象的一部分。
 ```

- **线程安全**：当多个线程访问一个对象时，如果不考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象是线程安全的。

#### 线程安全的实现方法

- **互斥同步(阻塞同步)**：互斥同步(Mutual Exclusion & Synchronization) 是常见的一种并发正确性保障手段。同步是指在多个线程并发访问共享数据时，保证数据共享在同一个时刻只被一个(使用信号量的时候是一些)线程使用。而互斥是实现同步的一种手段，临界区、互斥量、信号量都是主要的互斥实现方式。

```shell
	在Java中，最基本的互斥同步手段就是 synchronized 关键字，synchronized 关键字经过编译之后，会在同步块的前后分别形成monitorenter和monitorexit这两个字节码指令，这两个字节码都需要一个reference类型的参数来指明要锁定和解锁的对象。若Java程序中的synchronized明确指定了对象参数，则就是这个对象的reference；若没有明确指定，那就根据synchronized修饰的是实例方法还是类方法，去取对应的对象实例或Class对象来作为锁对象。
# 注意：1. synchronized 同步块对同一条线程来说是可重入的，不会出现自己把自己锁死的问题。
	   2. 同步块在已经进入的线程执行完之前，会阻塞后面其他线程的进入；
# synchronized 是重量级操作的原因：
	Java线程是映射到操作系统的原生线程之上的，若要阻塞或唤醒一个线程，都需要操作系统来帮忙完成，这就需要从用户态转换到核心态中，因此状态转换需要耗费很多的处理器时间。
# java.util.concurrent.ReentrantLock 可重入锁
	1. 等待可中断：正在等待的线程可以放弃等待处理其他事情；
	2. 可实现公平锁：多个线程在等待同一个锁时，必须按照申请锁的时间顺序来一次获得锁；
	3. 锁可绑定多个条件：一个ReentrantLock对象可以同时绑定多个condition对象；
```

- **非阻塞同步**：CAS 指令：CAS指令需要有3个操作数，分别是内存位置、旧的预期值和新值，CAS指令执行时，当且仅当V符合旧预期值A时，处理器用新值B更新V的值，否则它就不执行更新，但是无论是否更新了V的值，都会返回V的旧值，上述的处理过程是一个原子操作；CAS操作存在ABA问题；

```shell
# 悲观并发策略与乐观并发策略
	从处理问题的方式上说，互斥同步属于一种悲观的并发策略，总是认为只要不去做正确的同步措施(例如加锁)那就肯定会出现问题，无论共享数据是否真的会出现竞争，它都要进行加锁、用户态核心态转换、维护锁计数器和检查是否有被阻塞的线程需要唤醒等操作。
	基于冲突检测的乐观并发策略：先进行操作，如果没有其他线程争用共享数据，那操作就成功了；如果共享数据有争用，产生了冲突，那就在采取其他的补偿措施，这种乐观的并发策略的许多实现都不需要把线程挂起，因此这种同步操作称为非阻塞同步(Non-Blocking Synchronization)
```

- **无同步方案**：可重入代码和线程本地存储；

```shell
# 补充：临界区、互斥量、信号量、事件
链接: https://www.cnblogs.com/hiwoshixiaoyu/p/10035059.html
四种进程或线程同步互斥的控制方法
1、临界区:通过对多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问。
2、互斥量:为协调共同对一个共享资源的单独访问而设计的。
3、信号量:为控制一个具有有限数量用户资源而设计。
4、事 件:用来通知线程有一些事件已发生，从而启动后继任务的开始。

1.临界区（CriticalSection）（同一个进程内，实现互斥）
保证在某一时刻只有一个线程能访问数据的简便办法。在任意时刻只允许一个线程对共享资源进行访问。如果有多个线程试图同时访问临界区，那么在有一个线程进入后其他所有试图访问此临界区的线程将被挂起，并一直持续到进入临界区的线程离开。临界区在被释放后，其他线程可以继续抢占，并以此达到用原子方式操作共享资源的目的。

2.互斥量（Mutex）（可以跨进程，实现互斥）
互斥量跟临界区很相似，只有拥有互斥对象的线程才具有访问资源的权限，由于互斥对象只有一个，因此就决定了任何情况下此共享资源都不会同时被多个线程所访问。当前占据资源的线程在任务处理完后应将拥有的互斥对象交出，以便其他线程在获得后得以访问资源。互斥量比临界区复杂。因为使用互斥不仅仅能够在同一应用程序不同线程中实现资源的安全共享，而且可以在不同应用程序的线程之间实现对资源的安全共享。
互斥量与临界区的作用非常相似，但互斥量是可以命名的，也就是说它可以跨越进程使用。所以创建互斥量需要的资源更多，所以如果只为了在进程内部是用的话使用临界区会带来速度上的优势并能够减少资源占用量。

3.信号量（Semaphores）（主要是实现同步，可以跨进程）
信号量对象对线程的同步方式与前面几种方法不同，信号允许多个线程同时使用共享资源，这与操作系统中的PV操作相同。它指出了同时访问共享资源的线程最大数目。它允许多个线程在同一时刻访问同一资源，但是需要限制在同一时刻访问此资源的最大线程数目。一般是将当前可用资源计数设置为最大资源计数，每增加一个线程对共享资源的访问，当前可用资源计数就会减1，只要当前可用资源计数是大于0的，就可以发出信号量信号。但是当前可用计数减小到0时则说明当前占用资源的线程数已经达到了所允许的最大数目，不能在允许其他线程的进入，此时的信号量信号将无法发出

4.事件（Event）（实现同步，可以跨进程）
事件对象也可以通过通知操作的方式来保持线程的同步。并且可以实现不同进程中的线程同步操作。
```



### 锁优化

- **自旋锁**：请求锁的线程不放弃处理器的执行时间，看看持有锁的线程是否还快就会释放锁。为了让线程等待只需让线程执行一个忙循环(自旋)，这项技术就是所谓的自旋锁。
- **锁消除**：锁消除是指虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除；
- **锁粗化**
- **轻量级锁**：轻量级锁的执行过程：在代码进入同步块的时候，若此同步对象没有被锁定，虚拟机首先将在当前线程的栈帧中建立一个名为锁记录(Lock Record) 的空间，用于存储锁对象目前的Mark Word的拷贝；之后，虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针，若更新成功则线程就拥有了该对象的锁，对象此时处于轻量级锁定状态；若更新失败，有两条以上的线程争用同一个锁，那**轻量级锁就膨胀为重量级锁**；轻量级锁使用CAS操作消除同步使用的互斥量进而提升程序同步性能；

```shell
# HotSpot 虚拟机的对象头的内存布局
	HotSpot虚拟机的对象头(Object Header)分为两部分信息，第一部分用于存储对象自身的运行时数据，如哈希码、GC分代年龄等，称为"Mark Word"，是实现轻量级锁和偏向锁的关键。另一部分用于存储指向方法区对象类型数据的指针，如果是数组对象的话，还会有一个额外的部分用于存储数组长度。
```

- **偏向锁**：偏向锁的目的是消除数据在无竞争情况下的同步原语，进一步提高程序的运行性能。偏向锁是在无竞争的情况下把整个同步都取消掉，连CAS操作都不做了；偏向锁执行过程：当锁对象第一次被线程获取的时候虚拟机将会把对象头中的标志位设为“01”，即偏向模式。同时使用CAS操作把获取到这个线程的ID记录在对象的Mark Word之中，如果CAS操作成功，持有偏向锁的线程以后每次进入这个锁相关的同步块时，虚拟机都可以不再进行任何同步操作；当有另外一个线程去尝试获取这个锁时，偏向模式就宣告结束，根据锁对象目前是否处于被锁定的状态，撤销偏向锁后恢复到未锁定或轻量级锁定的状态；

![image-20210123105936997](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210123105936997.png)



### ThreadLocal

```html
参考博客：https://www.cnblogs.com/micrari/p/6790229.html
```

1. 什么是 ThreadLocal？ThreadLocal类顾名思义可以理解为本地变量。也就是说如果定义了一个ThreadLocal，每个线程往这个ThreadLocal中读写是线程隔离，互相之间是不会影响的。提供而一种将可变数据通过每个线程有自己的独立副本从而实现线程封闭的机制。
2. ThreadLocal 是如何实现的？Thread 类有一个类型为 ThreadLocal.ThreadLocalMap的实例变量threadLocals，也就是说每个线程有一个自己的ThreadLocalMap。ThreadLocalMap的key是ThreadLocal的弱引用，value为代码中放入的值。每个线程在往某个ThreadLocal里塞值的时候，都会往自己的ThreadLocalMap里存，读也是以某个ThreadLocal作为引用，在自己的map里找对应的key，从而实现了线程隔离。

**由于ThreadLocalMap使用线性探测法来解决散列冲突，所以实际上Entry[]数组在程序逻辑上是作为一个环形存在的。**

```shell
# ThreadLocal 读一个值可能遇到的情况：ThreadLocal.get()
根据入参threadLocal的threadLocalHashCode对表容量取模得到index
	如果index对应的slot就是要读的threadLocal，则直接返回结果
	调用getEntryAfterMiss线性探测，过程中每碰到无效slot，调用expungeStaleEntry进行段清理；如果找到了key，则返回结果entry
	没有找到key，返回null
```

```shell
# ThreadLocal的set方法可能会有的情况
	探测过程中slot都不无效，并且顺利找到key所在的slot，直接替换即可
	探测过程中发现有无效slot，调用replaceStaleEntry，效果是最终一定会把key和value放在这个slot，并且会尽可能清理无效slot
		在replaceStaleEntry过程中，如果找到了key，则做一个swap把它放到那个无效slot中，value置为新值
		在replaceStaleEntry过程中，没有找到key，直接在无效slot原地放entry
	探测没有发现key，则在连续段末尾的后一个空位置放上entry，这也是线性探测法的一部分。放完后，做一次启发式清理，如果没清理出去key，并且当前table大小已经超过阈值了，则做一次rehash，rehash函数会调用一次全量清理slot方法也即expungeStaleEntries，如果完了之后table大小超过了threshold - threshold / 4，则进行扩容2倍;
	
# ThreadLocal的remove方法可能会有的情况
remove方法相对于getEntry和set方法比较简单，直接在table中找key，如果找到了，把弱引用断了做一次段清理。
```







### JVM调优

线上定位问题就只能看日志、系统状态和dump线程。

- 选择合理的垃圾收集器；
- 计算内存需求(对象头(数组类型(3个字宽)和非数组类型(2个字宽))、实例对象)
- 设定年轻代和老年代大小
- 压力测试、分析日志

**-Xms、-Xmx设置堆内存初始值和最大值**，在通常情况下，服务器项目在运行过程中，堆空间会不断的收缩与扩张，势必会造成不必要的系统压力。所以在生产环境中，JVM的 Xms 和 Xmx要设置成一样的；

**-XX:MaxPermSize**，设置永久代大小

```shell
# 虚拟机性能监控与故障处理工具
	给一个系统定位问题的时候，知识、经验是关键基础，数据是依据，工具是运用知识处理数据的手段。这里说的数据包括：运行日志、异常堆栈、GC日志、线程快照(threaddump/javacore文件)、堆转储快照(headdump/hprof文件)等。
	jps：虚拟机进程状况工具，可以列出正在运行的虚拟机进程，并显示虚拟机执行主类名称以及这些进程的本地虚拟机唯一ID；
	jstat：虚拟机统计信息监视工具：可以显示本地或者远程虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据；
	jinfo：实时查看和调整虚拟机各项参数；
	jmap：Java内存映像工具：生成堆转储快照(一般称为heapdump或dump文件)
	jstack：生成虚拟机当前时刻的线程快照(一般称为threaddump或者javacore文件)，线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合，生成线程快照的主要目的是定位线程出现长时间停顿的原因。
	阿里巴巴开源的性能分析神器Arthas（阿尔萨斯）
```

jstat命令查看一下GC情况；线程dump下来查看；









